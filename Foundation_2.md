# Foundation_2
Sheldon  
November 29, 2015  

R에서는 여러 값을 하나로 모아서 처리하는 데 특장이 있습니다. 그리고 여러 값을 모아 주는 개념으로 ’벡터’가 있습니다. 수학적으로 벡터는 다른 의미가 있지만 일단 여기서는 그냥 ’여러 값을 하나로 모은 것’으로 이해합시다. 기본적으로 벡터는 c()를 이용해서 만들 수 있습니자.


```r
c(2, 3, 4, 5)
```

```
## [1] 2 3 4 5
```

```r
x <- c(2,3,4,5)
x
```

```
## [1] 2 3 4 5
```
이렇게 하면 x라는 벡터에 2, 3, 4, 5 라는 여러가지 값이 모여 있게 됩니다. 벡터를 생성하면 이로운 점이 여러 값에 대한 연산을 쉽게 할 수 있다는 것입니다. 앞에서 예를 들었던, sqrt(3), sqrt(4), sqrt(5), sqrt(6), sqrt(7)을 벡터를 이용해서 구해 봅시다.


```r
x <- c(3,4,5,6,7)
sqrt(x)
```

```
## [1] 1.732051 2.000000 2.236068 2.449490 2.645751
```
이처럼 x라는 벡터에 연산을 하면 하나하나 벡터의 원소에 대해서 따로따로 연산이 진행됩니다.

```r
log(x)
```

```
## [1] 1.098612 1.386294 1.609438 1.791759 1.945910
```

```r
sin(x)
```

```
## [1]  0.1411200 -0.7568025 -0.9589243 -0.2794155  0.6569866
```
어떤 경우에는 벡터의 크기를 알고 싶을 때가 있습니다. 벡터의 크기란 벡터가 몇 개의 구성요소를 가지고 있냐를 달리 이르는 말입니다. 만약 벡터가 3개의 요소로 구성되어 있으면 벡터의 크기는 3이 됩니다. 벡터의 크기를 구하는 명령어는 length()입니다.

```r
x <- c(3,4,5,6,7)
length(x)
```

```
## [1] 5
```
벡터끼리의 연산도 가능합니다. 이때는 서로 대응하는 각 요소끼리 일반 수치처럼 연산하는 것입니다.


```r
c(1,2,3) + c(4,5,6)  #이 경우 c(1+4, 2+5, 3+6)과 같습니다.
```

```
## [1] 5 7 9
```

```r
c(1,2,3)*c(4,5,6)  #이 경우 c(1*4, 2*5, 3*6)과 같습니다.
```

```
## [1]  4 10 18
```

```r
c(1,2,3)-c(4,5,6)  #이 경우 c(1-4, 2-5, 3-6)과 같습니다.
```

```
## [1] -3 -3 -3
```
벡터와 수치 하나를 연산 할 수도 있습니다.

```r
c(3,4,5) - 1
```

```
## [1] 2 3 4
```
벡터 간의 연산을 할 때 주의해야 할 점은 ’재사용’의 개념입니다. 원래 수학적으로는 길이가 다른 벡터의 덧셈, 뺄셈을 할 수 없습니다. 하지만 R에서는 긴 벡터의 길이가 짧은 벡터의 배수라면 그것이 가능합니다.


```r
x<-c(1,2,3,4)
y<-c(5,7)
x+y
```

```
## [1]  6  9  8 11
```
어떻게 이게 가능할까요? 그건 짧은 벡터가 재사용되었기 때문입니다. 자세히 설명하면 이 연산을 실행하기위해서 짧은 벡터가 이어 붙여저서 긴 벡터의 길이를 맞추게 된 것이죠. 즉, 위의 예를 통해서 설명하면 x+y의 연산을 위해서는 길이가 4인 벡터가 필요한데 길이가 2인 벡터 y가 1번 반복되어 길이를 4로 맞춘 것입니다. 즉, 실제로 y는 (5, 7)이지만 연산을 할 때는 (5, 7, 5, 7)이 되어 연산이 된 거죠. 이를 염두에 두고 다시 결과를 봅시다.

```r
x<-c(1,2,3,4)
y<-c(5,7)
x+y
```

```
## [1]  6  9  8 11
```
곱하기와 나누기도 마찬가지입니다. 이 때도 짧은 쪽의 벡터가 재사용됩니다.

```r
x<-c(1,5)
y<-c(3,4,5,6,7,8)
x*y
```

```
## [1]  3 20  5 30  7 40
```
벡터의 재사용은 연산을 편하게 하는 역할도 하지만 의도치 않게 수행되면 error를 유발할 수도 있습니다. 그러니까 R에서는 벡터가 재사용된다는 것을 유념합시다.

벡터 안의 각 수치를 ’요소’라고 부릅시다. 앞에서부터 번호를 세면 1번째 있는 것을 1번째 요소, 2번째 있는 것을 2번째 요소라고 부르는 것이죠. 데이터를 분석하다 보면 특정 벡터의 특정 요소만 추출하고 싶다거나 변환하고 싶은 상황이 생깁니다. 벡터의 요소를 알고 싶을 때는 다음과 같이 합니다. 벡터명[번호(몇 번째 요소인지)] 벡터의 요소를 변경하려면 다음과 같이 합니다. 벡터명[번호]<-값

```r
x<-c(3,5,7,9)
x[2]
```

```
## [1] 5
```
x[2]는 벡터 x의 두번째 요소를 확인하는 명령어입니다.

```r
x[2]<-20 #이것은 벡터  x의 2번째 요소를 20으로 바꿉다.
```
실제 시뮬레이션 등을 할 때는 1, 2, 3, 4, 5, … 처럼 규칙성 있는 벡터를 만드는 것이 필요할 때가 있습니다. 가장 간단하게 이런 벡터를 만드는 것은 : 를 활용하는 것입니다. 예를 들어 1:5를 입력하면 1에서 5까지 1씩 증가하는 벡터를 만들게 됩니다. 만약 5:1이라고 입력하면 5에서 1까지 1씩 감소하는 벡터를 만들게 되고요.

```r
1:5
```

```
## [1] 1 2 3 4 5
```

```r
5:1
```

```
## [1] 5 4 3 2 1
```
seq()와 rep()를 이용하면 좀 더 formal하게 규칙성 있는 벡터를 만들 수 있습니다. seq()는 간단하게 말하면 등차수열을 만드는 명령어입니다. 1:5는 사실 seq(1,5)와 같습니다. 그리고 만약 seq() 안에 length=3을 입력하면 등차수열을 유지하면서 길이가 3인 벡터를 만들라는 뜻입니다. 만약 seq(1,5,length=3)을 입력하면 1에서 5까지 길이가 3인 수열을 생성하겠죠. 실제 입력하면 어떻게 될까요?

```r
seq(1, 5, length = 3)
```

```
## [1] 1 3 5
```

```r
seq(1, 5, length=10)#이러면 1에서 5까지 길이가 10인 등차수열을 생성하라는 이야기입니다.
```

```
##  [1] 1.000000 1.444444 1.888889 2.333333 2.777778 3.222222 3.666667
##  [8] 4.111111 4.555556 5.000000
```

또 다른 seq()의 매개변수인 by는 항끼리의 차이, 공차를 지정해 줍니다. 만약 seq(1, 5, by=2)라고 입력하면 1에서 5까지 2씩 증가하는 등차수열을 생성합니다.

seq()에 대한 설명이 복잡하고 이해가 어려우면 help(seq)을 치고 자세한 설명을 보세요. R에서는 help(명령) 을 입력하면 알고 싶은 명령에 대한 도움말을 출력해 줍니다. 새로운 함수를 접할 때는 반드시 help()를 통해서 내용을 확인하는 습관을 들입시다!!!

```r
seq(1, 5, by=2)
```

```
## [1] 1 3 5
```

```r
seq(10, 2, by=-0.1) #공차는 반드시 양수일 필요가 없습니다.
```

```
##  [1] 10.0  9.9  9.8  9.7  9.6  9.5  9.4  9.3  9.2  9.1  9.0  8.9  8.8  8.7
## [15]  8.6  8.5  8.4  8.3  8.2  8.1  8.0  7.9  7.8  7.7  7.6  7.5  7.4  7.3
## [29]  7.2  7.1  7.0  6.9  6.8  6.7  6.6  6.5  6.4  6.3  6.2  6.1  6.0  5.9
## [43]  5.8  5.7  5.6  5.5  5.4  5.3  5.2  5.1  5.0  4.9  4.8  4.7  4.6  4.5
## [57]  4.4  4.3  4.2  4.1  4.0  3.9  3.8  3.7  3.6  3.5  3.4  3.3  3.2  3.1
## [71]  3.0  2.9  2.8  2.7  2.6  2.5  2.4  2.3  2.2  2.1  2.0
```

```r
seq(3, 100, by=0.5) 
```

```
##   [1]   3.0   3.5   4.0   4.5   5.0   5.5   6.0   6.5   7.0   7.5   8.0
##  [12]   8.5   9.0   9.5  10.0  10.5  11.0  11.5  12.0  12.5  13.0  13.5
##  [23]  14.0  14.5  15.0  15.5  16.0  16.5  17.0  17.5  18.0  18.5  19.0
##  [34]  19.5  20.0  20.5  21.0  21.5  22.0  22.5  23.0  23.5  24.0  24.5
##  [45]  25.0  25.5  26.0  26.5  27.0  27.5  28.0  28.5  29.0  29.5  30.0
##  [56]  30.5  31.0  31.5  32.0  32.5  33.0  33.5  34.0  34.5  35.0  35.5
##  [67]  36.0  36.5  37.0  37.5  38.0  38.5  39.0  39.5  40.0  40.5  41.0
##  [78]  41.5  42.0  42.5  43.0  43.5  44.0  44.5  45.0  45.5  46.0  46.5
##  [89]  47.0  47.5  48.0  48.5  49.0  49.5  50.0  50.5  51.0  51.5  52.0
## [100]  52.5  53.0  53.5  54.0  54.5  55.0  55.5  56.0  56.5  57.0  57.5
## [111]  58.0  58.5  59.0  59.5  60.0  60.5  61.0  61.5  62.0  62.5  63.0
## [122]  63.5  64.0  64.5  65.0  65.5  66.0  66.5  67.0  67.5  68.0  68.5
## [133]  69.0  69.5  70.0  70.5  71.0  71.5  72.0  72.5  73.0  73.5  74.0
## [144]  74.5  75.0  75.5  76.0  76.5  77.0  77.5  78.0  78.5  79.0  79.5
## [155]  80.0  80.5  81.0  81.5  82.0  82.5  83.0  83.5  84.0  84.5  85.0
## [166]  85.5  86.0  86.5  87.0  87.5  88.0  88.5  89.0  89.5  90.0  90.5
## [177]  91.0  91.5  92.0  92.5  93.0  93.5  94.0  94.5  95.0  95.5  96.0
## [188]  96.5  97.0  97.5  98.0  98.5  99.0  99.5 100.0
```
rep는 해당 벡터를 반복시킬 때 사용됩니다. rep(벡터, 반복수) 이런 식으로 함수가 구성됩니다. 그래서 rep(c(1,2), 5)라 입력하면 벡터 (1,2)를 5번 반복하라는 의미이죠.

```r
rep(c(1,2),5)
```

```
##  [1] 1 2 1 2 1 2 1 2 1 2
```
rep(7:3, 2) 요 명령은 어떤 결과를 출력할까요? 한 번 생각해 보고 직접 해 보세요.
