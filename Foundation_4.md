# Foundation4
Sheldon  
November 29, 2015  
여기서는 프로그래밍의 기본이라고 할 수 있는 if, else 조건분기문과 for반복문에 대해서 소개하겠습니다.

특정 조건에서 명령을 다르게 하고 싶을 때 R에서는 if문과 else문을 사용합니다. 형식은 다음과 같습니다. if (조건식) { 조건식이 TRUE일 때 실행하는 명령 } else { 조건식이 FALSE일 깨 실행하는 명령 } 예를 들어 입력변수가 a, b이고 a와 b중 더 큰 수치를 출력하는 함수 compare를 만들어 봅시다.

```r
compare <-function(a, b){
  if (a > b){  #if문을 사용해서 a가 b보다 클 때는 a를 출력하게 합니다.
    return (a)
  } else {
    return (b)
  }
}
compare(4,5)
```

```
## [1] 5
```

```r
compare(1, 100)
```

```
## [1] 100
```
사실 위 함수는 완벽하지 않습니다. a와 b가 같을 때는 함수의 프로세스에 따라 b를 출력하게 되는데 이건 우리가 원하는 것이 아니죠. a와 b가 같을 때는 문자 “same”을 출력하게 합시다. 이렇게 조건이 3개일 때는 2번째 조건으로 else if를 사용합니다. 다른 형식은 똑같고요. 문자를 출력하게 할 때는 따옴표를 문자 양 옆에 위치하게 해야 합니다. 안 그러고 그냥 same이라고 치면 R은 same이라는 변수를 찾아 헤매게 됩니다. 한 번 다시 만들어 봅시다.


```r
compare <-function(a, b){
  if (a > b){  
    return (a)
  } else if (a==b){  #else if를 사용했죠
    return("same")
  }
  
    else {
    return (b)
  }
}
compare(5,5.1)
```

```
## [1] 5.1
```

```r
compare(4,5.9)
```

```
## [1] 5.9
```

```r
compare(5,5)
```

```
## [1] "same"
```
어떤 명령을 반복해서 실행하고 싶을 때는 같은 명령을 반복해서 기입하는 것보다는 for문을 사용하는 게 좋습니다. n번 명령을 반복하고 싶다 할 때는 일반적으로 1:n 의 수열을 이용합니다.

for문의 형식은 다음과 같습니다. for (루프변수 in 리스트) { 반복할 식 }

이해를 위해서 어떻게 for문이 실제로 작동하는 지 알아 볼 필요가 있습니다. 예를 들어 for (i in 1:5)라고 하면 일단 루프변수 i가 취할 수 있는 리스트는 (1, 2, 3, 4, 5) 5개의 값으로 이루어져 있습니다. 처음 for문이 시작하면 i는 1이라는 숫자를 부여받게 됩니다. 그 다음에 { }안의 반복할 식이 수행되죠. 이 식의 수행이 끝나면 다시 처음으로 돌아옵니다. 그 다음에 i는 2라는 숫자를 부여받게 되고 다시 { }안의 식이 수행되죠. 이것을 반복합니다. i가 5라는 숫자를 부여받은 후 더이상 부여받을 숫자가 없을 때까지 말이죠. 그러면 반복할식은 5번 반복되게 됩니다. 과정을 살펴보면 아시겠지만 사실 i가 취하는 리스트 (1:5)라는 값 자체는 반복하는 횟수에 영항을 미치지 않습니다. 중요한 건 리스트의 길이(length)이죠. 그래서 for (i in 1:5) 나 for (i in 3:7)이나 반복하는 횟수는 같습니다. 여기서 이 둘의 차이는 만약 반복할 식 { }안에 루프변수가 있다면 취하는 값이 달라진다는 것입니다. 루프변수 i를 반복횟수를 정하는데만 사용할 수도 있지만 또한 이것을 { }안에 넣어 연산에 참여시키는 경우에 차이가 보이는 것이죠. 만약에 i+1을 5번 반복하고 하고 싶다하면, for (i in 1:5)와 for (i in 3:7)은 차이를 보이게 됩니다. 실제 실행해 봅시다.

```r
for (i in 1:5){
  i<-i+1 #i에 1을 더한 것을 다시 i로 지정해 줍니다.
  print(i) #return()은 function명령에 쓸 수 있는 거라 print()를 대신 사용했습니다.
}
```

```
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
```

```r
for (i in 3:7){
  i<-i+1 
  print(i) 
}
```

```
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
```
앞에서 설명한 for문 반복과정을 잘 곱씹으면 어떻게 이런 결과가 나왔는지 유추할 수 있을 것입니다. 처음 for문에서 i는 맨 처음에 1을 부여받고 { }안 식의 표현에 따라 2가 됩니다. 그리고 이렇게 바뀐 값을 출력하게 되고요. 그러면 { }안의 식이 끝납니다. 앞으로 돌아가 이번엔 i가 2로 바뀌고요. 이 과정을 리스트에서 더 이상 i가 취할 값이 없을 때까지 반복합니다. 이번에는 예제로 정수 n까지의 정수합을 구하는 function을 만들어 봅시다. function의 입력변수를 n이라고 하고요.

```r
sumup<-function(n){
  result<-0 #나중에 정수합을 저장해서 최종적으로 출력할 변수입니다. 이것은 반드시 for문 전에 미리 설정해 놓아야 합니다. 만약 for문 안에 이 문구가 있으면 for문이 반복될 때마다 우리의 결과는 0으로 초기화 됩니다.
  for (i in 1:n){
    result<-result+i 
    }
  return(result)  #for문이 다 끝나면 이렇게 결과를 출력합시다.  
}
sumup(3) #예상대로라면 1+2+3 이 출력되야겠죠.
```

```
## [1] 6
```

```r
sumup(10)
```

```
## [1] 55
```

```r
sumup(1000)
```

```
## [1] 500500
```
이번에는 지금까지 다루었던 분기문과 for문을 합쳐 다른 함수를 만들어 보겠습니다.

수치를 값으로 가지는 임의의 벡터을 입력변수로 하고, 그 벡터에서 2보다 작은 애들은 버리고 2보다 크거나 같은 애들만으로 벡터를 재구성시키는 함수 likemorethan2를 만들어 봅시다. 여기서 numeric()이라는 명령이 쓰이는데요. 원래 numeric은 0을 해당 숫자만큼 반복시키는 명령입니다. numeric(7)하면 0이 7개가 나열된 벡터가 생성되죠. 여기서는 원소가 없는 빈 벡터를 만들고자 numeric()을 사용했습니다. 이제부터 가급적 설명은 하지 않을게요. 코드를 보고 이해하는 게 중요하니까요.

```r
likemorethan2<-function(x){
  result<-numeric()
  for (i in x){
    if (i>=2){
      result<-c(result,i)
            }
      }
  return(result)
}
test1<- -5:5
test2<-c(5,4,-5, 6, -10,-9, 19, 3, 1, 2)
test3<-c(4,3, 5, 7, 2, 4, 1,9, 2.1, -2, 4, 5, 6)
likemorethan2(test1)
```

```
## [1] 2 3 4 5
```

```r
likemorethan2(test2)
```

```
## [1]  5  4  6 19  3  2
```

```r
likemorethan2(test3)
```

```
##  [1] 4.0 3.0 5.0 7.0 2.0 4.0 9.0 2.1 4.0 5.0 6.0
```

